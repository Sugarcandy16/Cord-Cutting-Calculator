  def Perference.cut_cord(must_have)
    # create a hash to store packages that already been collected
    collected_packages = Hash.new
    collected_packages.default = false
    # array store the package combinations
    results = []

    must_have.each do |channel| # for each must have channel
# ------------------part 1 initialization------------------------------------
      packages_id = [] # the corresponding packages for each channel
      packages_used = [] # packages in packages_id that have been used before
      packages_new = [] # packages in packages_id that have never been used

      # find corresponding channels
      ProvideChannel.where(channel_id: channel).each do |provide|
        packages_id << provide.package_id
      end # end package_id for
#------------------part 2 the first case-------------------------------------
      # if it is initial state
      if collected_packages.empty?

        packages_id.each do |id|
          collected_packages[id] = true
          results << [id]
        end # end package_id for

      else # for n to n+1 must_have channels
# ------------------part 3 find used packages-------------------------------- 
        # for each corresponding package
        packages_id.each do |id|
          # divide these packages into used and new 
          if collected_packages[id] == true
            packages_used << id
          else
            packages_new << id
            collected_packages[id] = true # for new packages, collect them in hash
          end # end if that divide used packages and new packages
        end # end packages_id for
# ----------------part 4 examine and form new combination--------------------
        # for each combination
        results.each do |result|
# ----------------part 4.1 determine whether include used packages----------
          # flag that tells whether this combination contains some used package
          flag_include_used = false 
          # examine each used package to see if any of it is include in the
          # combination
          packages_used.each do |used|
            # if include any used package, do not add new combination
            if result.include?(used)
              flag_include_used = true
            end # end if
          end # end packages_used for
# ---------------part 4.2 add new combinations------------------------------
          # if does not include any used package, form new combinations
          if flag_include_used == false
            new_results = []
            # for each new package and qualified combination
            packages_new.each do |new|
              new_result = Array.new(result) # grab qualified combination
              new_result << new # add new package
              new_results << new_result # add this combination into results
            end # end new packages for
            results = results + new_results
            results.delete(result) # delete original combination
          end # end form new combination if

        end # end each result

      end # end if else

    end # end must have channel loop
    return results
  end
